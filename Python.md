#### 1.列表（list）和元组（tuple）有什么区别?
    列表是可变的。创建后可以对其进行修改。
    元组是不可变的。元组一旦创建，就不能对其进行更改。
    列表表示的是顺序。它们是有序序列，通常是同一类型的对象。比如说按创建日期排序的所有用户名，如["Seth", "Ema", "Eli"]。
    元组表示的是结构。可以用来存储不同数据类型的元素。比如内存中的数据库记录，如(2, "Ema", "2020–04–16")（#id, 名称,创建日期）。
#### 2.Python中is 和 == 区别 and isnot 和 != 区别
    is比较的是两个对象的id。==比较的是两个对象的value
    is not是用来检查两个对象是否属于同一内存对象。!=如果两个变量或对象的值不相等，则返回true。
#### 3.什么是装饰器（decorator）？装饰器的写法以及应用场景。
    装饰器允许通过将现有函数传递给装饰器，从而向现有函数添加一些额外的功能，该装饰器将执行现有函数的功能和添加的额外功能。
#### 4.Python中类实例方法、类方法、静态方法有何区别？
    类实例方法: 是类实例化对象的方法,只有实例对象可以调用，形参为self,指代对象本身;
    静态方法: 是一个任意函数，在其上方使用 @staticmethod 进行装饰，可以用对象直接调用，静态方法实际上跟该类没有太大关系
    类方法: 是类对象的方法，在定义时需要在上方使用 @classmethod 进行装饰,形参为cls，表示类对象，类对象和实例对象都可调用
#### 5.func 和 func() 区别是什么？
    func是表示函数的对象，它可以被分配给变量或传递给另一个函数。
    带圆括号的func()调用该函数并返回其输出
#### 6. map、reduce、filter 函数工作原理
    Map函数返回一个列表，该列表由对序列中的每个元素应用一个函数时返回的值组成。
    reduce接受一个函数和一个序列，然后对序列进行迭代。在每次迭代中，当前元素和前一个元素的输出都传递给函数。最后返回一个值。
    filter 每个元素都被传递给一个函数，如果函数返回True，则在输出序列中返回该元素；如果函数返回False，则将其丢弃。
#### 7.类中的“self”指的是什么？
    “self”引用类本身的实例。这就是我们赋予方法访问权限并且能够更新方法所属对象的能力。
#### 8.Python里面如何拷贝一个对象？（赋值，浅拷贝，深拷贝的区别）
    赋值：  创建了对象的一个新的引用，修改其中任意一个变量都会影响到另一个。
    浅拷贝：创建一个新的对象，但它包含的是对原始对象中包含项的引用（如果用引用的方式修改其中一个对象，另外一个也会修改改变） {1,完全切片方法；2，工厂函数，如list()；3，copy模块的copy()函数}
    深拷贝：创建一个新的对象，并且递归的复制它所包含的对象（修改其中一个，另外一个不会改变）{copy模块的()函数}
#### 9. Python中的不可变数据类型和可变数据类型区别是什么
    不可变数据类型：
        指不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，而对于相同的值的对象，在内存中则只有一个对象（一个地址）。
        数值型、字符串string和元组tuple都属于不可变数据类型。
    可变数据类型:
        指允许变量的值发生变化，即如果对变量执行append、+=等操作，只会改变变量的值，而不会新建一个对象，变量引用的对象的地址也不会变化。
        不过对于相同的值的不同对象，在内存中会存在不同的对象，即每个对象都有自己的地址，
        相当于内存中对于同值的对象保存了多份，这里不存在引用计数，是实实在在的对象。列表list和字典dict都属于可变数据类型。
#### 10. Python代码是如何执行的？
    首先，解释器读取Python代码并检查是否有语法或格式错误。
    如果发现错误，则暂停执行。如果没有发现错误，则解释器会将Python代码转换为等效形式或字节代码。
    然后将字节码发送到Python虚拟机(PVM)，这里Python代码将被执行，如果发现任何错误，则暂停执行，否则结果将显示在输出窗口中。
#### 11.如何在Python中管理内存？
    Python内存由Python的私有headspace管理。
    所有的Python对象和数据结构都位于一个私有堆中。私用堆的分配由Python内存管理器负责。
    Python还内置了一个的垃圾收集器，可以回收未使用的内存并释放内存，使其可用于headspace
#### 12.Python中append，insert和extend的区别?
    append：在列表末尾添加新元素。
    insert：在列表的特定位置添加元素。
    extend：通过添加新列表来扩展列表。
#### 13 break、continue、pass是什么？
    break：在满足条件时，它将导致程序退出循环。
    continue：将返回到循环的开头，它使程序在当前循环迭代中的跳过所有剩余语句。
    pass：使程序传递所有剩余语句而不执行。
#### 14.区分Python中的remove，del和pop？
    remove：将删除列表中的第一个匹配值，它以值作为参数。
    del：使用索引删除元素，它不返回任何值。
    pop：将删除列表中顶部的元素，并返回列表的顶部元素。
#### 15.什么是lambda函数
    Lambda函数是不带名称的单行函数，可以具有n个参数，但只能有一个表达式。也称为匿名函数。
#### 16.iterables和iterators之间的区别？
    iterable：可迭代是一个对象，可以对其进行迭代。在可迭代的情况下，整个数据一次存储在内存中。
    iterators：迭代器是用来在对象上迭代的对象。它只在被调用时被初始化或存储在内存中。迭代器使用next从对象中取出元素。
#### 17 解释*args和**kwargs？
    *args，是当我们不确定要传递给函数参数的数量时使用的。
    **kwargs，是当我们想将字典作为参数传递给函数时使用的。
#### 18.解释re模块的split()、sub()、subn()方法？
    split()：只要模式匹配，此方法就会拆分字符串。
    sub()：此方法用于将字符串中的某些模式替换为其他字符串或序列。
    subn()：和sub()很相似，不同之处在于它返回一个元组，将总替换计数和新字符串作为输出。
#### 19.简述 生成器、迭代器、可迭代对象 以及应用场景？
    生成器(generator)的定义与普通函数类似，生成器使用yield关键字生成值。如果一个函数包含yield关键字，那么该函数将自动成为一个生成器。
    迭代器
    可迭代对象
#### 20.解释一下Python中的继承？,继承有什么特点，Python支持多继承吗
    继承(inheritance)允许一个类获取另一个类的所有成员和属性。
    继承提供代码可重用性，可以更轻松地创建和维护应用程序。
    被继承的类称为超类，而继承的类称为派生类/子类。
    特点：
    Python支持多继承，重继承意味着，一个类可以从多个父类派生。
#### 21.什么是抽象？、什么是封装、什么是多态
    抽象(Abstraction)是将一个对象的本质或必要特征向外界展示，并隐藏所有其他无关信息的过程。
    封装(Encapsulation)意味着将数据和成员函数包装在一起成为一个单元。
    多态(Polymorphism)的意思是「许多形式」。子类可以定义自己的独特行为，并且仍然共享其父类/基类的相同功能或行为。
#### 22.什么是Python中的猴子补丁？
     猴子补丁(monkey patching)，是指在运行时动态修改类或模块。
#### 23.谈谈你对闭包的理解？

#### 24.Python子类继承自多个父类时，如多个父类有同名方法，子类将继承自哪个方法？
       子类继承父类的方法是按照继承的父类的先后顺序确定的  
#### 25.Python垃圾回收机制？    
#### 26.如何在函数中设置一个全局变量
     globals()
#### 27.面向对象深度优先和广度优先是什么？
#### 28.面向对象中super的作用？
#### 29.是否使用过functools中的函数？其作用是什么？
#### 30.列举面向对象中带爽下划线的特殊方法，如：__new__、__init__
    （1） __new__至少要有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别。
    （2） __new__返回生成的实例，可以返回父类（通过super(当前类名, cls)的方式）__new__出来的实例，或者直接是对象的__new__出来的实例。这在自己编程实现__new__时要特别注意。
    （3） __init__有一个参数self，就是这个__new__返回的实例，__init__在__new__的基础上可以完成一些其它初始化的动作，init__不需要返回值。
    （4） 如果__new__创建的是当前类的实例，会自动调用__init，通过返回语句里面调用的__new__函数的第一个参数是cls来保证是当前类实例，如果是其他类的类名，那么实际创建并返回的就是其他类的实例，也就不会调用当前类或其他类的__init__函数。

#### 31.如何判断是函数还是方法？
    
#### 32.列举面向对象中的特殊成员以及应用场景

#### 33.metaclass作用？以及应用场景？


#### 34.请简述Python中如何避免死锁？
    死锁是指不同线程获取了不同的锁，但是线程间又希望获取对方的锁，双方都在等待对方释放锁，这种相互等待资源的情况就是死锁。
    Python语言可以使用threading.Condition对象，基于条件事件通知的形式去协调线程的运行，即可避免死锁。

#### 35.请描述抽象类和接口类的区别和联系
    1.抽象类： 规定了一系列的方法，并规定了必须由继承类实现的方法。
              由于有抽象方法的存在，所以抽象类不能实例化。
              可以将抽象类理解为毛坯房，门窗，墙面的样式由你自己来定，
              所以抽象类与作为基类的普通类的区别在于约束性更强
    2.接口类： 与抽象类很相似，表现在接口中定义的方法，必须由引用类实现，
              但他与抽象类的根本区别在于用途：与不同个体间沟通的规则，你要进宿舍需要有钥匙，
              这个钥匙就是你与宿舍的接口，你的舍友也有这个接口，所以他也能进入宿舍，你用手机通话，那么手机就是你与他人交流的接口
    3.区别和关联：
            1.接口是抽象类的变体，接口中所有的方法都是抽象的，而抽象类中可以有非抽象方法，抽象类是声明方法的存在而不去实现它的类
            2.接口可以继承，抽象类不行
            3.接口定义方法，没有实现的代码，而抽象类可以实现部分方法
            4.接口中基本数据类型为static而抽象类不是

#### 36.isinstance作用以及应用场景？
