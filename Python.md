#### 1.列表（list）和元组（tuple）有什么区别?
    列表是可变的。创建后可以对其进行修改。
    元组是不可变的。元组一旦创建，就不能对其进行更改。
    列表表示的是顺序。它们是有序序列，通常是同一类型的对象。比如说按创建日期排序的所有用户名，如["Seth", "Ema", "Eli"]。
    元组表示的是结构。可以用来存储不同数据类型的元素。比如内存中的数据库记录，如(2, "Ema", "2020–04–16")（#id, 名称,创建日期）。
#### 2.Python中is 和 ==  isnot 和 != 区别
    is比较的是两个对象的id。==比较的是两个对象的value
    is not是用来检查两个对象是否属于同一内存对象。!=如果两个变量或对象的值不相等，则返回true。
#### 3.什么是装饰器（decorator）？装饰器的写法以及应用场景。
    装饰器允许通过将现有函数传递给装饰器，从而向现有函数添加一些额外的功能，该装饰器将执行现有函数的功能和添加的额外功能。
#### 4.Python中类实例方法、类方法、静态方法有何区别？
    类实例方法: 是类实例化对象的方法,只有实例对象可以调用，形参为self,指代对象本身;
    静态方法: 是一个任意函数，在其上方使用 @staticmethod 进行装饰，可以用对象直接调用，静态方法实际上跟该类没有太大关系
    类方法: 是类对象的方法，在定义时需要在上方使用 @classmethod 进行装饰,形参为cls，表示类对象，类对象和实例对象都可调用
#### 5.func 和 func() 区别是什么？
    func是表示函数的对象，它可以被分配给变量或传递给另一个函数。
    带圆括号的func()调用该函数并返回其输出
#### 6. map、reduce、filter 函数工作原理
    Map函数返回一个列表，该列表由对序列中的每个元素应用一个函数时返回的值组成。
    reduce接受一个函数和一个序列，然后对序列进行迭代。在每次迭代中，当前元素和前一个元素的输出都传递给函数。最后返回一个值。
    filter 每个元素都被传递给一个函数，如果函数返回True，则在输出序列中返回该元素；如果函数返回False，则将其丢弃。
#### 7.类中的“self”指的是什么？
    “self”引用类本身的实例。这就是我们赋予方法访问权限并且能够更新方法所属对象的能力。
#### 8.Python里面如何拷贝一个对象？（赋值，浅拷贝，深拷贝的区别）
    赋值：  创建了对象的一个新的引用，修改其中任意一个变量都会影响到另一个。
    浅拷贝：创建一个新的对象，但它包含的是对原始对象中包含项的引用（如果用引用的方式修改其中一个对象，另外一个也会修改改变） {1,完全切片方法；2，工厂函数，如list()；3，copy模块的copy()函数}
    深拷贝：创建一个新的对象，并且递归的复制它所包含的对象（修改其中一个，另外一个不会改变）{copy模块的()函数}
#### 9. Python中的不可变数据类型和可变数据类型区别是什么
    不可变数据类型：
        指不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，而对于相同的值的对象，在内存中则只有一个对象（一个地址）。
        数值型、字符串string和元组tuple都属于不可变数据类型。
    可变数据类型:
        指允许变量的值发生变化，即如果对变量执行append、+=等操作，只会改变变量的值，而不会新建一个对象，变量引用的对象的地址也不会变化。
        不过对于相同的值的不同对象，在内存中会存在不同的对象，即每个对象都有自己的地址，
        相当于内存中对于同值的对象保存了多份，这里不存在引用计数，是实实在在的对象。列表list和字典dict都属于可变数据类型。
#### 10. Python代码是如何执行的？
    首先，解释器读取Python代码并检查是否有语法或格式错误。
    如果发现错误，则暂停执行。如果没有发现错误，则解释器会将Python代码转换为等效形式或字节代码。
    然后将字节码发送到Python虚拟机(PVM)，这里Python代码将被执行，如果发现任何错误，则暂停执行，否则结果将显示在输出窗口中。
#### 11.如何在Python中管理内存？
    Python内存由Python的私有headspace管理。
    所有的Python对象和数据结构都位于一个私有堆中。私用堆的分配由Python内存管理器负责。
    Python还内置了一个的垃圾收集器，可以回收未使用的内存并释放内存，使其可用于headspace
#### 12.Python中append，insert和extend的区别?
    append：在列表末尾添加新元素。
    insert：在列表的特定位置添加元素。
    extend：通过添加新列表来扩展列表。
#### 13 break、continue、pass是什么？
    break：在满足条件时，它将导致程序退出循环。
    continue：将返回到循环的开头，它使程序在当前循环迭代中的跳过所有剩余语句。
    pass：使程序传递所有剩余语句而不执行。
#### 14.区分Python中的remove，del和pop？
    remove：将删除列表中的第一个匹配值，它以值作为参数。
    del：使用索引删除元素，它不返回任何值。
    pop：将删除列表中顶部的元素，并返回列表的顶部元素。
#### 15.什么是lambda函数
    Lambda函数是不带名称的单行函数，可以具有n个参数，但只能有一个表达式。也称为匿名函数。
#### 16.iterables和iterators之间的区别？
    iterable：可迭代是一个对象，可以对其进行迭代。在可迭代的情况下，整个数据一次存储在内存中。
    iterators：迭代器是用来在对象上迭代的对象。它只在被调用时被初始化或存储在内存中。迭代器使用next从对象中取出元素。
#### 17 解释*args和**kwargs？
    *args，是当我们不确定要传递给函数参数的数量时使用的。
    **kwargs，是当我们想将字典作为参数传递给函数时使用的。
#### 18.解释re模块的split()、sub()、subn()方法？
    split()：只要模式匹配，此方法就会拆分字符串。
    sub()：此方法用于将字符串中的某些模式替换为其他字符串或序列。
    subn()：和sub()很相似，不同之处在于它返回一个元组，将总替换计数和新字符串作为输出。
#### 19.简述 生成器(generator)、迭代器（iterator）、可迭代对象（Iterable） 以及应用场景？
    可迭代对象（Iterable）
        Python中经常使用for来对某个对象进行遍历，此时被遍历的这个对象就是可迭代对象，
        像常见的list,tuple都是。如果给一个准确的定义的话，就是只要它定义了可以返回一个迭代器的__iter__方法，
        或者定义了可以支持下标索引的__getitem__方法(这些双下划线方法会在其他章节中全面解释)，
        那么它就是一个可迭代对象。
    迭代器（iterator）
        迭代器是通过next()来实现的，每调用一次他就会返回下一个元素，
        当没有下一个元素的时候返回一个StopIteration异常，所以实际上定义了这个方法的都算是迭代器     
    生成器(generator)
        构造迭代器的最简单有力的工具，与普通函数不同的只有在返回一个值的时候使用yield来替代return，然后yield会自动构建好next()和iter()
#### 20.解释一下Python中的继承？,继承有什么特点，Python支持多继承吗
    继承(inheritance)允许一个类获取另一个类的所有成员和属性。
    继承提供代码可重用性，可以更轻松地创建和维护应用程序。
    被继承的类称为超类，而继承的类称为派生类/子类。
    特点：
    Python支持多继承，重继承意味着，一个类可以从多个父类派生。
#### 21.什么是抽象？、什么是封装、什么是多态
    抽象(Abstraction)是将一个对象的本质或必要特征向外界展示，并隐藏所有其他无关信息的过程。
    封装(Encapsulation)意味着将数据和成员函数包装在一起成为一个单元。
    多态(Polymorphism)的意思是「许多形式」。子类可以定义自己的独特行为，并且仍然共享其父类/基类的相同功能或行为。
#### 22.什么是Python中的猴子补丁？
     猴子补丁(monkey patching)，是指在运行时动态修改类或模块。
#### 23.谈谈你对闭包的理解？
    一个函数内部,嵌套了函数，这个内部函数对外部作用域的变量进行引用，那么这个内部函数称为闭包。
    用途:
        1.访问函数内部的变量 2.防止函数内部的变量执行完城后，被销毁，使其一直保存在内存中。
    缺点：
        由于闭包会引起外层函数作用域里的变量，因此闭包函数比非闭包函数更占内存，当外层函数执行完毕以后，
        外层函数的作用域变量仍然被闭包函数饮用者，不会被垃圾回收掉，因而会引起内存泄露。过度使用闭包导致内存占用过多，甚至内存泄露
        
#### 24.Python子类继承自多个父类时，如多个父类有同名方法，子类将继承自哪个方法？
       子类继承父类的方法是按照继承的父类的先后顺序确定的  
#### 25.Python垃圾回收机制？    
    1.什么是垃圾：
        python解释器执行定义变量的时候，申请内存空间来存放变量的值，而内存大小是有限的。
        这就涉及到变量所占用内存空间回收的问题，如果一个变量没用（简称垃圾）,那么占据的内存就应该立马回收掉，别耽误内存空间
        如何区别哪些变量是有用，哪些是没用的
        当我们定义一个变量且将变量保存起来，为了就是以后使用的时候方便，(我们将x进行赋值 x=1,1被x直接引用，创建list =[x],1被x引用，1也被list引用）
        当一个变量不在绑定任何引用的时候，我们就无法在访问到这个变量的值，那么这个变量值就相当于一个垃圾被回收掉
    2.什么是垃圾回收机制
         垃圾回收机制（简称GC）是Python解释器自带一种机，专门用来回收不可用的变量值所占用的内存空间
    3.为什么要用垃圾回收
          程序运行过程中会申请大量的内存空间，而对于一些无用的内存空间如果不及时清理的话会导致内存使用殆尽（内存溢出），导致程序崩溃，因此管理内存是一件重要且繁杂的事情，而python解释器自带的垃圾回收机制把程序员从繁杂的内存管理中解放出来。
    4.垃圾回收机制原理
        主要运用了“引用计数”（reference counting）来跟踪和回收垃圾
        在引用计数的基础上，还可以通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用的问题，
        并且通过“分代回收”（generation collection）以空间换取时间的方式来进一步提高垃圾回收的效率。
       4.1 什么是引用计数
            引用计数就是：变量值被变量名关联的次数  （如：x=1,变量值1被关联一个变量名x,成为1）
            引用计数增加： x =1 此时引用计数为1，a = x，x的内存地址给了a,那么a,x都关联1，引用计数为2
            引用计数减少：(x=1, 变量x先与1解除关联，只剩下了a还跟1关联这，那么引用计数从2减少到1）
              如果引用计数一旦为0，那么直接出发python垃圾回收机制，直接给回收了将内存释放出来
       4.2 引用计数扩展阅读
            变量值被关联次数增加或者减少，都会引发引用计数执行，这明显存在效率问题。
            如果说执行效率仅仅是引用计数一个小问题，那么引用计数还存在一个循环引用大问题
            
            循环引用会导致：值不再被任何名字关联，但是值的引用计数并不会为0，应该被回收但不能被回收
                列表1与列表2之间的相互引用，两个列表的引用计数均不为0，但两个列表不再被任何其他对象关联，
                没有任何人可以再引用到它们，所以它俩占用内存空间应该被回收，但由于相互引用的存在，
                每一个对象的引用计数都不为0，因此这些对象所占用的内存永远不会被释放，所以循环引用是致命的，
                这与手动进行内存管理所产生的内存泄露毫无区别。 
            Python引入了“标记-清除” 与“分代回收”来分别解决引用计数的循环引用与效率低的问题
        4.2.1 “标记-清除”
              容器对象都可以包含对其他对象的引用，所以都可能产生循环引用。而“标记-清除”计数就是为了解决循环引用的问题。
              关于变量的存储，内存中有两块区域：堆区与栈区，
              在定义变量时，变量名与值内存地址的关联关系存放于栈区，变量值存放于堆区，
              内存管理回收的则是堆区的内容
        4.2.2 分代回收
              基于引用计数的回收机制，每次回收内存，都需要把所有对象的引用计数都遍历一遍，这是非常消耗时间的，于是引入了分代回收来提高回收效率，分代回收采用的是用“空间换时间”的策略。
              分代回收的核心思想是：在历经多次扫描的情况下，都没有被回收的变量，gc机制就会认为，该变量是常用变量，gc对其扫描的频率会降低，具体实现原理如下：
                分代指的是根据存活时间来为变量划分不同等级（也就是不同的代）
                新定义的变量，放到新生代这个等级中，假设每隔1分钟扫描新生代一次，
                如果发现变量依然被引用，那么该对象的权重（权重本质就是个整数）加一，
                当变量的权重大于某个设定得值（假设为3），会将它移动到更高一级的青春代，青春代的gc扫描的频率低于新生代（扫描时间间隔更长），
                假设5分钟扫描青春代一次，这样每次gc需要扫描的变量的总个数就变少了，节省了扫描的总时间，接下来，青春代中的对象，也会以同样的方式被移动到老年代中。也就是等级（代）越高，被垃圾回收机制扫描的频率越低         
#### 26.如何在函数中设置一个全局变量
     globals()
#### 27.面向对象深度优先和广度优先是什么？
     Python的类可以继承多个类，Python的类如果继承了多个类，那么其寻找方法的方式有两种
     当类是经典类时，多继承情况下，会按照深度优先方式查找  py3
     当类是新式类时，多继承情况下，会按照广度优先方式查找  py2
     简单点说就是：经典类是纵向查找，新式类是横向查找
     经典类和新式类的区别就是，在声明类的时候，新式类需要加上object关键字。在python3中默认全是新式类
#### 28.面向对象中super的作用？
    当父类的方法无法在子类的实现的时候，需要重写父类的方法，重新方法就是用 super
#### 29.如何判断是函数还是方法？
    函数：封装了一些独立的功能，可以直接调用，python内置了许多函数，同时可以自建函数来使用
    方法：方法和函数类似，同样封装了独立的功能，但是方法是需要通过对象来调用的，表示针对这个对象要做的操作
#### 30.列举面向对象中带爽下划线的特殊方法，如：__new__、__init__
    （1） __new__至少要有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别。
    （2） __new__返回生成的实例，可以返回父类（通过super(当前类名, cls)的方式）__new__出来的实例，或者直接是对象的__new__出来的实例。这在自己编程实现__new__时要特别注意。
    （3） __init__有一个参数self，就是这个__new__返回的实例，__init__在__new__的基础上可以完成一些其它初始化的动作，init__不需要返回值。
    （4） 如果__new__创建的是当前类的实例，会自动调用__init，通过返回语句里面调用的__new__函数的第一个参数是cls来保证是当前类实例，如果是其他类的类名，那么实际创建并返回的就是其他类的实例，也就不会调用当前类或其他类的__init__函数。
#### 31.isinstance作用以及应用场景？
    作用：来判断一个对象是否是一个已知的类型；
    isinstance(变量名，类型)，返回true或false
    
#### 32.列举面向对象中的特殊成员以及应用场景
    __dict__ 查看类或对象中的所有成员
    __str__ 如果一个类中定义了__str__方法，那么在打印对象时，默认输出该方法的返回值
    __getitem__ 、 __setitem__ 、__delitem__ 用于索引操作，如字典。分别表示获取、设置、删除数据
#### 33.哪些操作会导致Python内存溢出，怎么处理？
    内存中加载的数据量过于庞大，如一次从数据库取出过多数据；
    集合类中有对对象的引用，使用完后未清空，产生了堆积，使得PVM不能回收；
    代码中存在死循环或循环产生过多重复的对象实体；
    启动参数内存值设定的过小
#### 34.请简述Python中如何避免死锁？
    死锁是指不同线程获取了不同的锁，但是线程间又希望获取对方的锁，双方都在等待对方释放锁，这种相互等待资源的情况就是死锁。
    Python语言可以使用threading.Condition对象，基于条件事件通知的形式去协调线程的运行，即可避免死锁。
#### 35.请描述抽象类和接口类的区别和联系
    1.抽象类： 规定了一系列的方法，并规定了必须由继承类实现的方法。
              由于有抽象方法的存在，所以抽象类不能实例化。
              可以将抽象类理解为毛坯房，门窗，墙面的样式由你自己来定，
              所以抽象类与作为基类的普通类的区别在于约束性更强
    2.接口类： 与抽象类很相似，表现在接口中定义的方法，必须由引用类实现，
              但他与抽象类的根本区别在于用途：与不同个体间沟通的规则，你要进宿舍需要有钥匙，
              这个钥匙就是你与宿舍的接口，你的舍友也有这个接口，所以他也能进入宿舍，你用手机通话，那么手机就是你与他人交流的接口
    3.区别和关联：
            1.接口是抽象类的变体，接口中所有的方法都是抽象的，而抽象类中可以有非抽象方法，抽象类是声明方法的存在而不去实现它的类
            2.接口可以继承，抽象类不行
            3.接口定义方法，没有实现的代码，而抽象类可以实现部分方法
            4.接口中基本数据类型为static而抽象类不是
#### 36.函数调用参数的传递方式是值传递还是引用传递？
    Python的参数传递有：位置参数、默认参数、可变参数、关键字参数。
    函数的传值到底是值传递还是引用传递、要分情况：
    不可变参数用值传递：像整数和字符串这样的不可变对象，是通过拷贝进行传递的，因为你无论如何都不可能在原处改变不可变对象。
    可变参数是引用传递：比如像列表，字典这样的对象是通过引用传递、和C语言里面的用指针传递数组很相似，可变对象能在函数内部改变。
#### 37.hasattr() getattr() setattr() 函数使用详解？
    hasattr() 判断一个对象里面是否有name属性或者name方法，返回BOOL值，有name特性返回True,否则返回False。
    getattr()获取对象object的属性或者方法，如果存在打印出来，如果不存在，打印出默认值，默认值可选。
    setattr()给对象的属性赋值，若属性不存在，先创建再赋值。
#### 38.什么是单例模式、单例模式应用场景
    一个类下面只有一个实例
    场景：资源共享的情况下，避免由于资源操作时导致的性能或损耗等。
         控制资源的情况下，方便资源之间的互相通信。如线程池等，1,网站的计数器 2,应用配置 3.多线程池 4数据库配置 数据库连接池 5.应用程序的日志应用...
    class Singleton(object):
        def __new__(cls, *args, **kw):
            if not hasattr(cls, '_instance'):
                orig = super(Singleton, cls)
                cls._instance = orig.__new__(cls, *args, **kw)
            return cls._instance
    class MyClass(Singleton):
        a = 1
#### 40.Python 自省    
    程序运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().
#### 41.鸭子类型
    简单来说：
        不关心对象是什么类型，只关心行为是什么。
        比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等. 
        鸭子类型在动态语言中经常使用，非常灵活，使得python不想java那样专门去弄一大堆的设计模式。